type Token_Kind : enum {
    Invalid,
    Left_Parenthesis,
    Right_Parenthesis,
    Left_Curly_Brace,
    Right_Curly_Brace,
    Left_Brace,
    Right_Brace,
    Semicolon,
    Colon,
    Period,
    Double_Period,
    Comma,
    Equals,
    Double_Equal,
    Plus,
    Minus,
    Asterisk,
    Slash,
    Percent,
    Ampersand,
    Double_Ampersand,
    Double_Bar,
    Exclamation,
    Exclamation_Equal,
    Less,
    Less_Equal,
    Greater,
    Greater_Equal,

    Identifier,
    Number,
    String,
    Character,
}

type Token : struct {
    kind: Token_Kind,
    data: String
}

proc lex(contents: String, allocator: Allocator) {
    var tokens: Dynamic_Array = dynamic_array_new!(contents.length / 3, allocator, $type Token);
    var in_string: bool = false;
    var in_character: bool = false;
    var in_comment: bool = false;
    var buffer_start: uint = 0;

    var i: uint = 0;
    while i < contents.length {
        var character: byte = contents.pointer[i];
        var next_character: byte = '\0';
        if i + 1 < contents.length {
            next_character = contents.pointer[i + 1];
        };

        if in_comment {
            if character == '\n' {
                in_comment = false;
            };
            i = i + 1;
        } else if in_string || in_character {
            var a: uint;
            if character == '"' || character == '\'' {
                var substring: String = string_from_range(contents, buffer_start, i);

                var kind: Token_Kind = Invalid;
                if in_string {
                    kind = String;
                } else if in_character {
                    kind = Character;
                };

                dynamic_array_append!(&tokens, @build(Token, kind, substring), $type Token);
                in_string = false;
                in_character = false;
                i = i + 1;
                buffer_start = i;
            } else {
                i = i + 1;
            };
        } else {
            if      character == '|' && next_character == '|' handle_lex_token(contents, &tokens, &buffer_start, &i, Double_Bar, 2)
            else if character == '=' && next_character == '=' handle_lex_token(contents, &tokens, &buffer_start, &i, Double_Equal, 2)
            else if character == '!' && next_character == '=' handle_lex_token(contents, &tokens, &buffer_start, &i, Exclamation_Equal, 2)
            else if character == '<' && next_character == '=' handle_lex_token(contents, &tokens, &buffer_start, &i, Less_Equal, 2)
            else if character == '>' && next_character == '=' handle_lex_token(contents, &tokens, &buffer_start, &i, Greater_Equal, 2)
            else if character == '&' && next_character == '&' handle_lex_token(contents, &tokens, &buffer_start, &i, Double_Ampersand, 2)
            else if character == '.' && next_character == '.' handle_lex_token(contents, &tokens, &buffer_start, &i, Double_Period, 2)
            else if character == '('  handle_lex_token(contents, &tokens, &buffer_start, &i, Left_Parenthesis, 1)
            else if character == ')'  handle_lex_token(contents, &tokens, &buffer_start, &i, Right_Parenthesis, 1)
            else if character == '{'  handle_lex_token(contents, &tokens, &buffer_start, &i, Left_Curly_Brace, 1)
            else if character == '}'  handle_lex_token(contents, &tokens, &buffer_start, &i, Right_Curly_Brace, 1)
            else if character == '['  handle_lex_token(contents, &tokens, &buffer_start, &i, Left_Brace, 1)
            else if character == ']'  handle_lex_token(contents, &tokens, &buffer_start, &i, Right_Brace, 1)
            else if character == ';'  handle_lex_token(contents, &tokens, &buffer_start, &i, Semicolon, 1)
            else if character == ':'  handle_lex_token(contents, &tokens, &buffer_start, &i, Colon, 1)
            else if character == '.'  handle_lex_token(contents, &tokens, &buffer_start, &i, Period, 1)
            else if character == ','  handle_lex_token(contents, &tokens, &buffer_start, &i, Comma, 1)
            else if character == '+'  handle_lex_token(contents, &tokens, &buffer_start, &i, Plus, 1)
            else if character == '-'  handle_lex_token(contents, &tokens, &buffer_start, &i, Minus, 1)
            else if character == '*'  handle_lex_token(contents, &tokens, &buffer_start, &i, Asterisk, 1)
            else if character == '%'  handle_lex_token(contents, &tokens, &buffer_start, &i, Percent, 1)
            else if character == '!'  handle_lex_token(contents, &tokens, &buffer_start, &i, Exclamation, 1)
            else if character == '='  handle_lex_token(contents, &tokens, &buffer_start, &i, Equals, 2)
            else if character == '<'  handle_lex_token(contents, &tokens, &buffer_start, &i, Greater, 2)
            else if character == '>'  handle_lex_token(contents, &tokens, &buffer_start, &i, Less, 2)
            else if character == '&'  handle_lex_token(contents, &tokens, &buffer_start, &i, Ampersand, 2)
            else if character == ' '  handle_lex_token(contents, &tokens, &buffer_start, &i, Invalid, 1)
            else if character == '\n' handle_lex_token(contents, &tokens, &buffer_start, &i, Invalid, 1)
            else if character == '/' {
                if next_character == '/' {
                    handle_lex_token(contents, &tokens, &buffer_start, &i, Invalid, 2);
                    in_comment = true;
                } else {
                    handle_lex_token(contents, &tokens, &buffer_start, &i, Slash, 1);
                };
            } else if character == '"' {
                in_string = true;
                lex_buffer(contents, &tokens, &buffer_start, &i);
                i = i + 1;
                buffer_start = i;
            } else if character == '\'' {
                in_character = true;
                lex_buffer(contents, &tokens, &buffer_start, &i);
                i = i + 1;
                buffer_start = i;
            } else {
                i = i + 1;
            };
        };
    };

    var i: uint = 0;
    while i < tokens.count {
        var token: Token = dynamic_array_get!(&tokens, i, $type Token);

        if token.kind == Identifier {
            print!("Ident: {}\n", token.data);
        } else if token.kind == Number {
            print!("Number: {}\n", token.data);
        } else if token.kind == String {
            print!("String: \"{}\"\n", token.data);
        } else if token.kind == Character {
            print!("Character: '{}'\n", token.data);
        } else if token.kind == Left_Parenthesis {
            print!("LeftParen\n");
        } else if token.kind == Right_Parenthesis {
            print!("RightParen\n");
        } else if token.kind == Left_Curly_Brace {
            print!("LeftCurly\n");
        } else if token.kind == Right_Curly_Brace {
            print!("RightCurly\n");
        } else if token.kind == Comma {
            print!("Comma\n");
        } else if token.kind == Semicolon {
            print!("Semicolon\n");
        } else if token.kind == Colon {
            print!("Colon\n");
        } else if token.kind == Equals {
            print!("Equals\n");
        } else {
            print!("Unknown\n");
        };
        i = i + 1;
    };
}

proc handle_lex_token(contents: String, tokens: *Dynamic_Array, buffer_start: *uint, index: *uint, token_kind: Token_Kind, token_length: uint) {
    lex_buffer(contents, tokens, buffer_start, index);
    if token_kind != Invalid {
        dynamic_array_append!(tokens, @build(Token, token_kind, string_new_empty()), $type Token);
    };
    index.* = index.* + token_length;
    buffer_start.* = index.*;
}

proc lex_buffer(contents: String, tokens: *Dynamic_Array, buffer_start: *uint, index: *uint) {
    if (buffer_start.* - index.*) > 0 {
        var token_kind: Token_Kind = Identifier;
        var substring: String = string_from_range(contents, buffer_start.*, index.*);
        if substring.pointer[0] >= '0' && substring.pointer[0] <= '9' {
            token_kind = Number;
        };

        dynamic_array_append!(tokens, @build(Token, token_kind, substring), $type Token);
    };
}
