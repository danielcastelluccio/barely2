type Barely_Elf_Linux_X64_State : struct {
    process: Barely_Process_State,
    code_buffer: Buffer,
    data_buffer: Buffer,
    string_references: Dynamic_Array, // Barely_Elf_Linux_X64_String_Reference
    procedure_references: Dynamic_Array, // Barely_Elf_Linux_X64_Procedure_Reference
    procedure_locations: Hash_Map, // String, uint
    local_variables: Hash_Map, // String, uint
    local_variable_index: uint,
    main_offset: uint,
    statement_extra_stack: uint,
}

type Barely_Elf_Linux_X64_String_Reference : struct {
    deferred: X64_Deferred_Value,
    string_offset: uint,
}

type Barely_Elf_Linux_X64_Procedure_Reference : struct {
    deferred: X64_Deferred_Value,
    procedure_name: String,
}

proc hash_string(value: ptr): uint {
    return string_hash(@cast(*String, value));
}

proc barely_elf_linux_x64_get_size(state: *Barely_Elf_Linux_X64_State, type_: Barely_Ast_Type): uint {
    if type_.kind == Internal {
        var internal: Barely_Ast_Type_Internal = type_.data.internal;
        if internal == Uint {
            return 8;
        } else {
            unreachable(@file, @line);
        };
    } else if type_.kind == Struct {
        var struct_: Barely_Ast_Type_Struct = type_.data.struct_;
        var size: uint = 0;
        var i: uint = 0;
        while i < struct_.items.count {
            var item: *Barely_Ast_Name_Type = dynamic_array_get_ref!(&struct_.items, i, $type Barely_Ast_Name_Type);
            size = size + barely_elf_linux_x64_get_size(state, item.type_);
            i = i + 1;
        };
        return size;
    } else if type_.kind == Identifier {
        var i: uint = 0;
        while i < state.process.file.items.count {
            var item: *Barely_Ast_Item = dynamic_array_get_ref!(&state.process.file.items, i, $type Barely_Ast_Item);
            if item.kind == Type {
                if string_equal(item.data.type_.name, type_.data.identifier) {
                    return barely_elf_linux_x64_get_size(state, item.data.type_.type_);
                };
            };
            i = i + 1;
        };

        unreachable(@file, @line);
    } else if type_.kind == Pointer {
        return 8;
    };

    unreachable(@file, @line);
    return 0;
}

type Barely_Elf_Linux_X64_Item_Storage : struct {
    location: uint,
    size: uint,
}

proc barely_elf_linux_x64_get_item_storage(state: *Barely_Elf_Linux_X64_State, parent_type: *Barely_Ast_Type, item_name: String): Barely_Elf_Linux_X64_Item_Storage {
    if parent_type.kind == Identifier {
        var found: bool, item: *Barely_Ast_Item = barely_resolve_identifier_global(&state.process, parent_type.data.identifier);
        if !found {
            assert_(false, @file, @line);
        };
        assert_(item.kind == Type, @file, @line);
        return barely_elf_linux_x64_get_item_storage(state, &item.data.type_.type_, item_name);
    } else if parent_type.kind == Pointer {
        return barely_elf_linux_x64_get_item_storage(state, parent_type.data.pointer.inner, item_name);
    };

    assert_(parent_type.kind == Struct, @file, @line);

    var struct_: *Barely_Ast_Type_Struct = &parent_type.data.struct_;
    
    var result: Barely_Elf_Linux_X64_Item_Storage = @init(Barely_Elf_Linux_X64_Item_Storage);
    var i: uint = 0;
    while i < struct_.items.count {
        var item: *Barely_Ast_Name_Type = dynamic_array_get_ref!(&struct_.items, i, $type Barely_Ast_Name_Type);
        if string_equal(item.name, item_name) {
            result.size = barely_elf_linux_x64_get_size(state, item.type_);
            return result;
        };
        result.location = result.location + barely_elf_linux_x64_get_size(state, item.type_);
        i = i + 1;
    };

    return @init(Barely_Elf_Linux_X64_Item_Storage);
}

proc barely_elf_linux_x64_gen(file: Barely_Ast_File, allocator: Allocator) {
    var output: Buffer = buffer_create(4096, allocator);

    var state: Barely_Elf_Linux_X64_State = @build(Barely_Elf_Linux_X64_State, 
        @build(Barely_Process_State, 
            &file,
            null,
            hash_map_new!(0, allocator, hash_string, $type String, $type Barely_Ast_Type),
            false,
            allocator
            dynamic_array_new!(16, allocator, null, $type Barely_Ast_Type)),
        buffer_create(1024, allocator), 
        buffer_create(1024, allocator), 
        dynamic_array_new!(256, allocator, null, $type Barely_Elf_Linux_X64_String_Reference), 
        dynamic_array_new!(256, allocator, null, $type Barely_Elf_Linux_X64_Procedure_Reference),
        hash_map_new!(32, allocator, hash_string, $type String, $type uint),
        hash_map_new!(0, allocator, hash_string, $type String, $type uint),
        0,
        0,
        0);

    var entry: X64_Deferred_Value = x64_push_mov_register64_literal64_deferred(&state.code_buffer, RAX);
    x64_push_call_register64(&state.code_buffer, RAX);
    x64_push_mov_register64_literal64(&state.code_buffer, RAX, 60);
    x64_push_syscall(&state.code_buffer);

    var i: uint = 0;
    while i < file.items.count {
        var item: *Barely_Ast_Item = dynamic_array_get_ref!(&file.items, i, $type Barely_Ast_Item);
        barely_elf_linux_x64_gen_item(&state, item);
        i = i + 1;
    };

    var header_size: uint = 64 + 56 * 2;
    var code_offset: uint = header_size + 4294967296;
    var data_offset: uint = code_offset + state.code_buffer.index + 4096;

    x64_deferred_value_set(&entry, &state.code_buffer, @cast(uint64, code_offset + state.main_offset));

    var i: uint = 0;
    while i < state.string_references.count {
        var reference: Barely_Elf_Linux_X64_String_Reference =
            dynamic_array_get!(&state.string_references, i, $type Barely_Elf_Linux_X64_String_Reference);
        x64_deferred_value_set(&reference.deferred, &state.code_buffer, @cast(uint64, data_offset + reference.string_offset));
        i = i + 1;
    };

    var i: uint = 0;
    while i < state.procedure_references.count {
        var reference: Barely_Elf_Linux_X64_Procedure_Reference =
            dynamic_array_get!(&state.procedure_references, i, $type Barely_Elf_Linux_X64_Procedure_Reference);

        var procedure_location: uint, found: bool = hash_map_get!(&state.procedure_locations, reference.procedure_name, $type String, $type uint);
        assert_(found, @file, @line);
        x64_deferred_value_set(&reference.deferred, &state.code_buffer, @cast(uint64, code_offset + procedure_location));
        i = i + 1;
    };

    var header: Elf64_Header = elf64_header_create();
    elf64_header_set_endianness(&header, Little);
    elf64_header_set_abi(&header, Linux);
    elf64_header_set_type(&header, Executable);
    elf64_header_set_instruction_set(&header, X86_64);
    header.program_header_count = 2;
    header.entry = @cast(uint64, code_offset);

    var code_header: Elf64_Program_Header = elf64_program_header_create();
    elf64_program_header_set_type(&code_header, Loadable);
    elf64_program_header_set_flags(&code_header, Elf64_Segment_Readable + Elf64_Segment_Executable);
    code_header.file_offset = @cast(uint64, header_size);
    code_header.file_size = @cast(uint64, state.code_buffer.index);
    code_header.virtual_offset = @cast(uint64, code_offset);
    code_header.virtual_size = @cast(uint64, state.code_buffer.index);
    code_header.alignment = 4096;

    var data_header: Elf64_Program_Header = elf64_program_header_create();
    elf64_program_header_set_type(&data_header, Loadable);
    elf64_program_header_set_flags(&data_header, Elf64_Segment_Readable);
    data_header.file_offset = @cast(uint64, header_size + state.code_buffer.index);
    data_header.file_size = @cast(uint64, state.data_buffer.index);
    data_header.virtual_offset = @cast(uint64, code_offset + state.code_buffer.index + 4096);
    data_header.virtual_size = @cast(uint64, state.data_buffer.index);
    data_header.alignment = 4096;

    buffer_push_data(&output, @cast(ptr, &header), @sizeof(Elf64_Header));
    buffer_push_data(&output, @cast(ptr, &code_header), @sizeof(Elf64_Program_Header));
    buffer_push_data(&output, @cast(ptr, &data_header), @sizeof(Elf64_Program_Header));
    buffer_push_data(&output, @cast(ptr, state.code_buffer.data), state.code_buffer.index);
    buffer_push_data(&output, @cast(ptr, state.data_buffer.data), state.data_buffer.index);

    var output_file: File = file_open_for_writing("output2");
    var writer: Writer = file_writer_create(&output_file);
    write_buffer(writer, output.data, output.index);
    file_close(output_file);
}

proc barely_elf_linux_x64_gen_item(state: *Barely_Elf_Linux_X64_State, item: *Barely_Ast_Item) {
    if item.kind == Procedure {
        barely_elf_linux_x64_gen_procedure(state, &item.data.procedure);
    } else if item.kind == Type {
    } else {
        unreachable(@file, @line);
    };
}

proc barely_elf_linux_x64_gen_procedure(state: *Barely_Elf_Linux_X64_State, procedure: *Barely_Ast_Item_Procedure) {
    state.process.procedure = procedure;
    state.process.local_variables = hash_map_new!(16, state.process.allocator, hash_string, $type String, $type Barely_Ast_Type);
    state.local_variables = hash_map_new!(16, state.process.allocator, hash_string, $type String, $type uint);
    state.local_variable_index = 0;

    hash_map_insert!(&state.procedure_locations, procedure.name, state.code_buffer.index, $type String, $type uint);
    if string_equal(procedure.name, string_new("main")) {
        state.main_offset = state.code_buffer.index;
    };
    
    x64_push_push_register64(&state.code_buffer, RBP);
    x64_push_mov_register64_register64(&state.code_buffer, RBP, RSP);

    // Kind of a hack because I don't want to support 32 bit deferred values
    var deferred: X64_Deferred_Value = x64_push_mov_register64_literal64_deferred(&state.code_buffer, RAX);
    x64_push_sub_register64_register64(&state.code_buffer, RSP, RAX);

    var i: uint = 0;
    while i < state.process.procedure.returns.count {
        var return_type: Barely_Ast_Type = dynamic_array_get!(&state.process.procedure.returns, i, $type Barely_Ast_Type);
        var return_type_size: uint = barely_elf_linux_x64_get_size(state, return_type);
        state.local_variable_index = state.local_variable_index + return_type_size;
        i = i + 1;
    };

    var argument_stack_location: uint = 0;
    var i: uint = 0;
    while i < procedure.arguments.count {
        var argument: *Barely_Ast_Name_Type = dynamic_array_get_ref!(&procedure.arguments, procedure.arguments.count - i - 1, $type Barely_Ast_Name_Type);
        var argument_size: uint = barely_elf_linux_x64_get_size(state, argument.type_);
        if argument_size > 8 {
            x64_push_mov_register64_register64_pointer_offset(&state.code_buffer, RAX, RBP, @cast(uint32, 16 + argument_stack_location));
            var j: uint = 0;
            while j < argument_size {
                if j + 8 <= argument_size {
                    x64_push_mov_register64_register64_pointer_offset(&state.code_buffer, RBX, RAX, @cast(uint32, j));
                    x64_push_mov_register64_pointer_offset_register64(&state.code_buffer, RBP, @cast(uint32, 0 - (state.local_variable_index + argument_size + 8) + j), RBX);
                    j = j + 8;
                } else {
                    unreachable(@file, @line);
                };
            };
            state.local_variable_index = state.local_variable_index + argument_size;
        };
        argument_stack_location = argument_stack_location + argument_size;
        i = i + 1;
    };

    barely_elf_linux_x64_gen_expression(state, &procedure.body);

    x64_deferred_value_set(&deferred, &state.code_buffer, @cast(uint64, state.local_variable_index + 8));

    x64_push_mov_register64_register64(&state.code_buffer, RSP, RBP);
    x64_push_pop_register64(&state.code_buffer, RBP);
    x64_push_ret(&state.code_buffer);
}

proc barely_elf_linux_x64_gen_expression(state: *Barely_Elf_Linux_X64_State, expression: *Barely_Ast_Expression) {
    if expression.kind == Block {
        barely_elf_linux_x64_gen_block(state, &expression.data.block);
    } else if expression.kind == Retrieve {
        barely_elf_linux_x64_gen_retrieve(state, &expression.data.retrieve);
    } else if expression.kind == Invoke {
        barely_elf_linux_x64_gen_invoke(state, &expression.data.invoke);
    } else if expression.kind == Syscall {
        barely_elf_linux_x64_gen_syscall(state, &expression.data.syscall);
    } else if expression.kind == Number {
        barely_elf_linux_x64_gen_number(state, &expression.data.number);
    } else if expression.kind == String {
        barely_elf_linux_x64_gen_string(state, &expression.data.string);
    } else if expression.kind == Multiple {
        barely_elf_linux_x64_gen_multiple(state, &expression.data.multiple);
    } else if expression.kind == Reference {
        barely_elf_linux_x64_gen_reference(state, &expression.data.reference);
    } else {
        unreachable(@file, @line);
    };
}

proc barely_elf_linux_x64_resolve_argument_location(state: *Barely_Elf_Linux_X64_State, name: String): uint {
    var result: uint = 0;
    var i: uint = 0;
    while i < state.process.procedure.arguments.count {
        var argument: *Barely_Ast_Name_Type = dynamic_array_get_ref!(&state.process.procedure.arguments, state.process.procedure.arguments.count - i - 1, $type Barely_Ast_Name_Type);
        if string_equal(argument.name, name) {
            return result;
        };
        result = result + barely_elf_linux_x64_get_size(state, argument.type_);
        i = i + 1;
    };

    return @init(uint);
}

proc barely_elf_linux_x64_resolve_argument_location_big(state: *Barely_Elf_Linux_X64_State, name: String): uint {
    var result: uint = 0;
    var i: uint = 0;
    while i < state.process.procedure.arguments.count {
        var argument: *Barely_Ast_Name_Type = dynamic_array_get_ref!(&state.process.procedure.arguments, state.process.procedure.arguments.count - i - 1, $type Barely_Ast_Name_Type);
        var size: uint = barely_elf_linux_x64_get_size(state, argument.type_);
        if size > 8 {
            result = result + size;
        };

        if string_equal(argument.name, name) {
            return result;
        };
        i = i + 1;
    };

    return @init(uint);
}

proc barely_elf_linux_x64_gen_retrieve(state: *Barely_Elf_Linux_X64_State, retrieve: *Barely_Ast_Retrieve) {
    if retrieve.kind == Identifier {
        var valid: bool, resolved: *Barely_Ast_Item = barely_resolve_identifier_global(&state.process, retrieve.data.identifier);
        if valid {
            if resolved.kind == Procedure {
                var deferred: X64_Deferred_Value = x64_push_mov_register64_literal64_deferred(&state.code_buffer, RAX);
                x64_push_push_register64(&state.code_buffer, RAX);

                var procedure_ref: Barely_Elf_Linux_X64_Procedure_Reference = @build(Barely_Elf_Linux_X64_Procedure_Reference,
                    deferred,
                    retrieve.data.identifier);
                dynamic_array_append!(&state.procedure_references, procedure_ref, $type Barely_Elf_Linux_X64_Procedure_Reference);
                return;
            };
        };

        var local_index: uint, found: bool = hash_map_get!(&state.local_variables, retrieve.data.identifier, $type String, $type uint);
        if found {
            var local_type: Barely_Ast_Type, found: bool = hash_map_get!(&state.process.local_variables, retrieve.data.identifier, $type String, $type Barely_Ast_Type);
            var size: uint = barely_elf_linux_x64_get_size(state, local_type);
            if state.process.in_reference || size > 8 {
                x64_push_lea_register64_register64_pointer_offset(&state.code_buffer, RAX, RBP, @cast(uint32, 0 - (local_index + 8)));
                x64_push_push_register64(&state.code_buffer, RAX);
            } else {
                assert_(size == 8, @file, @line);
                x64_push_mov_register64_register64_pointer_offset(&state.code_buffer, RAX, RBP, @cast(uint32, 0 - (local_index + 8)));
                x64_push_push_register64(&state.code_buffer, RAX);
            };
            state.process.in_reference = false;
            return;
        };

        var argument_type: Barely_Ast_Type, found: bool = barely_resolve_argument(&state.process, retrieve.data.identifier);
        if found {
            var argument_location: uint = barely_elf_linux_x64_resolve_argument_location(state, retrieve.data.identifier);

            var size: uint = barely_elf_linux_x64_get_size(state, argument_type);
            if size > 8 {
                var argument_location_big: uint = barely_elf_linux_x64_resolve_argument_location_big(state, retrieve.data.identifier);
                x64_push_lea_register64_register64_pointer_offset(&state.code_buffer, RAX, RBP, @cast(uint32, 0 - (argument_location_big + 8)));
                x64_push_push_register64(&state.code_buffer, RAX);
            } else {
                if state.process.in_reference {
                    x64_push_lea_register64_register64_pointer_offset(&state.code_buffer, RAX, RBP, @cast(uint32, argument_location + 16));
                    x64_push_push_register64(&state.code_buffer, RAX);
                } else {
                    assert_(size == 8, @file, @line);
                    x64_push_mov_register64_register64_pointer_offset(&state.code_buffer, RAX, RBP, @cast(uint32, argument_location + 16));
                    x64_push_push_register64(&state.code_buffer, RAX);
                };
            };
            state.process.in_reference = false;
            return;
        };
    } else if retrieve.kind == Parent {
        var in_reference: bool = state.process.in_reference;
        state.process.in_reference = false;

        if retrieve.data.parent.parent_type.kind != Pointer {
            state.process.in_reference = true;
        };

        barely_elf_linux_x64_gen_expression(state, retrieve.data.parent.parent);
        x64_push_pop_register64(&state.code_buffer, RAX);

        var item_data: Barely_Elf_Linux_X64_Item_Storage = barely_elf_linux_x64_get_item_storage(state, &retrieve.data.parent.parent_type, retrieve.data.parent.item);

        if in_reference {
            x64_push_lea_register64_register64_pointer_offset(&state.code_buffer, RBX, RAX, @cast(uint32, item_data.location));
            x64_push_push_register64(&state.code_buffer, RBX);
        } else {
            assert_(item_data.size == 8, @file, @line);
            x64_push_mov_register64_register64_pointer_offset(&state.code_buffer, RBX, RAX, @cast(uint32, item_data.location));
            x64_push_push_register64(&state.code_buffer, RBX);
        };
        return;
    };

    unreachable(@file, @line);
}

proc barely_elf_linux_x64_gen_invoke(state: *Barely_Elf_Linux_X64_State, invoke: *Barely_Ast_Invoke) {
    x64_push_push_register64(&state.code_buffer, RDX);

    var i: uint = 0;
    while i < invoke.arguments.count {
        var argument: *Barely_Ast_Expression = dynamic_array_get_ref!(&invoke.arguments, i, $type Barely_Ast_Expression);
        barely_elf_linux_x64_gen_expression(state, argument);
        i = i + 1;
    };

    barely_elf_linux_x64_gen_expression(state, invoke.procedure);

    x64_push_pop_register64(&state.code_buffer, RAX);
    x64_push_call_register64(&state.code_buffer, RAX);

    x64_push_pop_register64(&state.code_buffer, RDX);

    var procedure_type: *Barely_Ast_Type_Procedure = &invoke.procedure_type.data.procedure;
    if procedure_type.returns.count > 0 {
        var total_returns_size: uint = 0;
        var i: uint = 0;
        while i < procedure_type.returns.count {
            var return_type: Barely_Ast_Type = dynamic_array_get!(&procedure_type.returns, i, $type Barely_Ast_Type);
            var return_type_size: uint = barely_elf_linux_x64_get_size(state, return_type);

            if return_type_size > 8 {
                var j: uint = 0;
                while j < return_type_size {
                    if j + 8 <= return_type_size {
                        x64_push_mov_register64_register64_pointer_offset(&state.code_buffer, RBX, RAX, @cast(uint32, total_returns_size + j));
                        x64_push_mov_register64_pointer_offset_register64(&state.code_buffer, RDX, @cast(uint32, state.statement_extra_stack + j), RBX);
                        j = j + 8;
                    } else {
                        unreachable(@file, @line);
                    };
                };
                x64_push_lea_register64_register64_pointer_offset(&state.code_buffer, RAX, RDX, @cast(uint32, state.statement_extra_stack));
                x64_push_push_register64(&state.code_buffer, RAX);
                state.statement_extra_stack = state.statement_extra_stack + return_type_size;
            } else {
                assert_(return_type_size == 8, @file, @line);
                x64_push_mov_register64_register64_pointer_offset(&state.code_buffer, RBX, RAX, @cast(uint32, total_returns_size));
                x64_push_push_register64(&state.code_buffer, RBX);
            };

            total_returns_size = total_returns_size + return_type_size;
            i = i + 1;
        };
    };
}

proc barely_elf_linux_x64_gen_syscall(state: *Barely_Elf_Linux_X64_State, syscall: *Barely_Ast_Syscall) {
    var i: uint = 0;
    while i < syscall.arguments.count {
        var argument: *Barely_Ast_Expression = dynamic_array_get_ref!(&syscall.arguments, i, $type Barely_Ast_Expression);
        barely_elf_linux_x64_gen_expression(state, argument);
        i = i + 1;
    };

    if syscall.arg_count > 5 {
        x64_push_pop_register64(&state.code_buffer, R9);
    };

    if syscall.arg_count > 4 {
        x64_push_pop_register64(&state.code_buffer, R8);
    };

    if syscall.arg_count > 3 {
        x64_push_pop_register64(&state.code_buffer, R10);
    };

    if syscall.arg_count > 2 {
        x64_push_pop_register64(&state.code_buffer, RDX);
    };

    if syscall.arg_count > 1 {
        x64_push_pop_register64(&state.code_buffer, RSI);
    };

    if syscall.arg_count > 0 {
        x64_push_pop_register64(&state.code_buffer, RDI);
    };

    x64_push_pop_register64(&state.code_buffer, RAX);
    x64_push_syscall(&state.code_buffer);
}

proc barely_elf_linux_x64_gen_number(state: *Barely_Elf_Linux_X64_State, number: *Barely_Ast_Number) {
    x64_push_mov_register64_literal64(&state.code_buffer, RAX, @cast(uint64, number.data.integer));
    x64_push_push_register64(&state.code_buffer, RAX);
}

proc barely_elf_linux_x64_gen_string(state: *Barely_Elf_Linux_X64_State, string: *Barely_Ast_String) {
    var string_ref: Barely_Elf_Linux_X64_String_Reference = @build(Barely_Elf_Linux_X64_String_Reference,
        x64_push_mov_register64_literal64_deferred(&state.code_buffer, RAX),
        state.data_buffer.index);
    dynamic_array_append!(&state.string_references, string_ref, $type Barely_Elf_Linux_X64_String_Reference);
    buffer_push_string(&state.data_buffer, string.value);

    x64_push_push_register64(&state.code_buffer, RAX);
}

proc barely_elf_linux_x64_gen_multiple(state: *Barely_Elf_Linux_X64_State, multiple: *Barely_Ast_Multiple) {
    var i: uint = 0;
    while i < multiple.expressions.count {
        var expression: *Barely_Ast_Expression = dynamic_array_get_ref!(&multiple.expressions, i, $type Barely_Ast_Expression);
        barely_elf_linux_x64_gen_expression(state, expression);
        i = i + 1;
    };
}

proc barely_elf_linux_x64_gen_reference(state: *Barely_Elf_Linux_X64_State, reference: *Barely_Ast_Reference) {
    state.process.in_reference = true;
    barely_elf_linux_x64_gen_expression(state, reference.inner);
}

proc barely_elf_linux_x64_gen_block(state: *Barely_Elf_Linux_X64_State, block: *Barely_Ast_Block) {
    var i: uint = 0;
    while i < block.statements.count {
        var statement: *Barely_Ast_Statement = dynamic_array_get_ref!(&block.statements, i, $type Barely_Ast_Statement);
        barely_elf_linux_x64_gen_statement(state, statement);
        i = i + 1;
    };
}

proc barely_elf_linux_x64_gen_statement(state: *Barely_Elf_Linux_X64_State, statement: *Barely_Ast_Statement) {
    state.statement_extra_stack = 0;

    var deferred: X64_Deferred_Value = x64_push_mov_register64_literal64_deferred(&state.code_buffer, RAX);
    x64_push_mov_register64_register64(&state.code_buffer, RDX, RSP);
    x64_push_sub_register64_register64(&state.code_buffer, RSP, RAX);

    if statement.kind == Expression {
        barely_elf_linux_x64_gen_expression(state, &statement.data.expression.expression);
    } else if statement.kind == Declaration {
        barely_elf_linux_x64_gen_declaration(state, &statement.data.declaration);
    } else if statement.kind == Assign {
        barely_elf_linux_x64_gen_assign(state, &statement.data.assign);
    } else if statement.kind == Return {
        barely_elf_linux_x64_gen_return(state, &statement.data.return_);
    } else {
        unreachable(@file, @line);
    };

    x64_deferred_value_set(&deferred, &state.code_buffer, @cast(uint64, state.statement_extra_stack));
    if state.statement_extra_stack > 0 {
        x64_push_mov_register64_literal64(&state.code_buffer, RAX, @cast(uint64, state.statement_extra_stack));
        x64_push_add_register64_register64(&state.code_buffer, RSP, RAX);
    };
}

proc barely_elf_linux_x64_gen_declaration(state: *Barely_Elf_Linux_X64_State, declaration: *Barely_Ast_Declaration) {
    var expression: *Barely_Ast_Expression = declaration.expression;

    if expression != null {
        barely_elf_linux_x64_gen_expression(state, expression);
    };

    var i: uint = 0;
    while i < declaration.declarations.count {
        var declaration: *Barely_Ast_Name_Type = dynamic_array_get_ref!(&declaration.declarations, declaration.declarations.count - i - 1, $type Barely_Ast_Name_Type);
        state.local_variable_index = state.local_variable_index + barely_elf_linux_x64_get_size(state, declaration.type_);
        hash_map_insert!(&state.local_variables, declaration.name, state.local_variable_index, $type String, $type uint);
        hash_map_insert!(&state.process.local_variables, declaration.name, declaration.type_, $type String, $type Barely_Ast_Type);

        var local_index: uint, found: bool = hash_map_get!(&state.local_variables, declaration.name, $type String, $type uint);
        if expression != null {
            x64_push_pop_register64(&state.code_buffer, RAX);

            var local_type: Barely_Ast_Type, found: bool = hash_map_get!(&state.process.local_variables, declaration.name, $type String, $type Barely_Ast_Type);
            var size: uint = barely_elf_linux_x64_get_size(state, local_type);
            if size > 8 {
                var j: uint = 0;
                while j < size {
                    if j + 8 <= size {
                        x64_push_mov_register64_register64_pointer_offset(&state.code_buffer, RCX, RAX, @cast(uint32, j));
                        x64_push_mov_register64_pointer_offset_register64(&state.code_buffer, RBP, @cast(uint32, 0 - (local_index + 8) + j), RCX);
                        j = j + 8;
                    } else {
                        unreachable(@file, @line);
                    };
                };
            } else {
                assert_(size == 8, @file, @line);
                x64_push_mov_register64_pointer_offset_register64(&state.code_buffer, RBP, @cast(uint32, 0 - (local_index + 8)), RAX);
            };
        };

        i = i + 1;
    };
}

proc barely_elf_linux_x64_gen_return(state: *Barely_Elf_Linux_X64_State, return_: *Barely_Ast_Return) {
    if return_.expression != null {
        barely_elf_linux_x64_gen_expression(state, return_.expression);
    };

    var return_size_index: uint = 0;
    var i: uint = 0;
    while i < state.process.procedure.returns.count {
        var return_type: Barely_Ast_Type = dynamic_array_get!(&state.process.procedure.returns, state.process.procedure.returns.count - i - 1, $type Barely_Ast_Type);
        var return_type_size: uint = barely_elf_linux_x64_get_size(state, return_type);
        if return_type_size > 8 {
            x64_push_pop_register64(&state.code_buffer, RAX);

            var j: uint = 0;
            while j < return_type_size {
                if j + 8 <= return_type_size {
                    x64_push_mov_register64_register64_pointer_offset(&state.code_buffer, RBX, RAX, @cast(uint32, i));
                    x64_push_mov_register64_pointer_offset_register64(&state.code_buffer, RBP, @cast(uint32, 0 - (return_size_index + 8)), RBX);
                    j = j + 8;
                } else {
                    unreachable(@file, @line);
                };
            };
        } else {
            assert_(return_type_size == 8, @file, @line);

            x64_push_pop_register64(&state.code_buffer, RAX);
            x64_push_mov_register64_pointer_offset_register64(&state.code_buffer, RBP, @cast(uint32, 0 - (return_size_index + 8)), RAX);
        };
        return_size_index = return_size_index + return_type_size;
        i = i + 1;
    };

    x64_push_lea_register64_register64_pointer_offset(&state.code_buffer, RAX, RBP, @cast(uint32, 0 - 8));

    x64_push_mov_register64_register64(&state.code_buffer, RSP, RBP);
    x64_push_pop_register64(&state.code_buffer, RBP);
    x64_push_ret(&state.code_buffer);
}

proc barely_elf_linux_x64_gen_assign(state: *Barely_Elf_Linux_X64_State, assign: *Barely_Ast_Assign) {
    barely_elf_linux_x64_gen_expression(state, assign.expression);

    var i: uint = 0;
    while i < assign.parts.count {
        var assign_part: *Barely_Ast_Assign_Part = dynamic_array_get_ref!(&assign.parts, assign.parts.count - i - 1, $type Barely_Ast_Assign_Part);
        barely_elf_linux_x64_gen_assign_part(state, assign_part);
        i = i + 1;
    };
}

proc barely_elf_linux_x64_gen_assign_part(state: *Barely_Elf_Linux_X64_State, assign_part: *Barely_Ast_Assign_Part) {
    if assign_part.kind == Identifier {
        var local_index: uint, found: bool = hash_map_get!(&state.local_variables, assign_part.data.identifier, $type String, $type uint);
        if found {
            var local_type: Barely_Ast_Type, found: bool = hash_map_get!(&state.process.local_variables, assign_part.data.identifier, $type String, $type Barely_Ast_Type);
            var size: uint = barely_elf_linux_x64_get_size(state, local_type);
            if size > 8 {
                x64_push_pop_register64(&state.code_buffer, RAX);
                var i: uint = 0;
                while i < size {
                    if i + 8 <= size {
                        x64_push_mov_register64_register64_pointer_offset(&state.code_buffer, RCX, RAX, @cast(uint32, i));
                        x64_push_mov_register64_pointer_offset_register64(&state.code_buffer, RBP, @cast(uint32, 0 - (local_index + 8) + i), RCX);
                        i = i + 8;
                    } else {
                        unreachable(@file, @line);
                    };
                };
            } else {
                assert_(size == 8, @file, @line);
                x64_push_pop_register64(&state.code_buffer, RAX);
                x64_push_mov_register64_pointer_offset_register64(&state.code_buffer, RBP, @cast(uint32, 0 - (local_index + 8)), RAX);
            };
            return;
        };
    } else if assign_part.kind == Parent {
        x64_push_pop_register64(&state.code_buffer, RBX);

        if assign_part.data.parent.parent_type.kind != Pointer {
            state.process.in_reference = true;
        };

        barely_elf_linux_x64_gen_expression(state, assign_part.data.parent.parent);
        x64_push_pop_register64(&state.code_buffer, RAX);

        var item_data: Barely_Elf_Linux_X64_Item_Storage = barely_elf_linux_x64_get_item_storage(state, &assign_part.data.parent.parent_type, assign_part.data.parent.item);
        if item_data.size > 8 {
            var i: uint = 0;
            while i < item_data.size {
                if i + 8 <= item_data.size {
                    x64_push_mov_register64_register64_pointer_offset(&state.code_buffer, RCX, RBX, @cast(uint32, i));
                    x64_push_mov_register64_pointer_offset_register64(&state.code_buffer, RAX, @cast(uint32, item_data.location + i), RCX);
                    i = i + 8;
                } else {
                    unreachable(@file, @line);
                };
            };
        } else {
            assert_(item_data.size == 8, @file, @line);
            x64_push_mov_register64_pointer_offset_register64(&state.code_buffer, RAX, @cast(uint32, item_data.location), RBX);
        };
        return;
    };

    unreachable(@file, @line);
}
